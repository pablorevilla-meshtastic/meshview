{% extends "base.html" %}

{% block css %}
.timestamp {
    min-width: 10em;
    color: #ccc;
}

.chat-packet:nth-of-type(odd) { background-color: #3a3a3a; }
.chat-packet {
    border-bottom: 1px solid #555;
    padding: 3px 6px;      /* slightly more horizontal breathing room */
    border-radius: 6px;
    margin: 0;
}

/* Wider spacing between Bootstrap-style columns */
.chat-packet > [class^="col-"] {
    padding-left: 10px !important;
    padding-right: 10px !important;
    padding-top: 1px !important;
    padding-bottom: 1px !important;
}

.chat-packet:nth-of-type(even) { background-color: #333333; }

.channel {
    font-style: italic;
    color: #bbb;
}
.channel a {
    font-style: normal;
    color: #999;
}

@keyframes flash {
    0% { background-color: #ffe066; }
    100% { background-color: inherit; }
}
.chat-packet.flash { animation: flash 3.5s ease-out; }

.replying-to {
    font-size: 0.8em;
    color: #aaa;
    margin-top: 2px;
    padding-left: 10px;
}
.replying-to .reply-preview { color: #aaa; }
{% endblock %}

{% block body %}
<div id="chat-container">
    <div class="container" id="chat-log"></div>
</div>

<script>
document.addEventListener("DOMContentLoaded", async () => {
    const chatContainer = document.querySelector("#chat-log");
    if (!chatContainer) return console.error("#chat-log not found");

    let lastTime = null;
    const renderedPacketIds = new Set();
    const packetMap = new Map();
    let chatLang = {};

    // --- Reuse translation helper from base ---
    function applyTranslations(dict, root = document) {
        root.querySelectorAll("[data-translate]").forEach(el => {
            const key = el.dataset.translate;
            const val = dict[key];
            if (!val) return;
            if (el.placeholder) el.placeholder = val;
            else if (el.tagName === "INPUT" && el.value) el.value = val;
            else if (key === "footer") el.innerHTML = val;
            else el.textContent = val;
        });
    }

    function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text ?? "";
        return div.innerHTML;
    }

    function renderPacket(packet, highlight = false) {
        if (renderedPacketIds.has(packet.id)) return;
        renderedPacketIds.add(packet.id);
        packetMap.set(packet.id, packet);

        // NOTE: Temporary stopgap - fallback to import_time until old data with
        // import_time_us=0 is migrated/cleaned up. Can be simplified once all
        // legacy records have been updated.
        // Fall back to import_time if import_time_us is 0, null, or undefined
        let date;
        if (packet.import_time_us && packet.import_time_us > 0) {
            date = new Date(packet.import_time_us / 1000);
        } else if (packet.import_time) {
            date = new Date(packet.import_time);
        } else {
            // Last resort: use current time
            date = new Date();
        }
        const formattedTime = date.toLocaleTimeString([], { hour:"numeric", minute:"2-digit", second:"2-digit", hour12:true });
        const formattedDate = `${(date.getMonth()+1).toString().padStart(2,"0")}/${date.getDate().toString().padStart(2,"0")}/${date.getFullYear()}`;
        const formattedTimestamp = `${formattedTime} - ${formattedDate}`;

        let replyHtml = "";
        if (packet.reply_id) {
            const parent = packetMap.get(packet.reply_id);
            const replyPrefix = `<i data-translate="replying_to"></i>`;
            if (parent) {
                replyHtml = `
                    <div class="replying-to">
                        ${replyPrefix}
                        <strong>${escapeHtml((parent.long_name || "").trim() || `Node ${parent.from_node_id}`)}</strong>:
                        ${escapeHtml(parent.payload || "")}
                    </div>`;
            } else {
                replyHtml = `
                    <div class="replying-to">
                        ${replyPrefix}
                        <a href="/new_packet/${packet.reply_id}">${packet.reply_id}</a>
                    </div>`;
            }
        }

        const div = document.createElement("div");
        div.className = "row chat-packet" + (highlight ? " flash" : "");
        div.dataset.packetId = packet.id;
        div.innerHTML = `
            <span class="col-2 timestamp" title="${packet.import_time_us}">${formattedTimestamp}</span>
            <span class="col-2 channel">
                <a href="/new_packet/${packet.id}" title="${chatLang.view_packet_details || 'View details'}">ðŸ”Ž</a>
                 ${escapeHtml(packet.channel || "")}
            </span>
            <span class="col-3 nodename">
                <a href="/node/${packet.from_node_id}">
                    ${escapeHtml((packet.long_name || "").trim() || `Node ${packet.from_node_id}`)}
                </a>
            </span>
            <span class="col-5 message">${escapeHtml(packet.payload)}${replyHtml}</span>
        `;
        chatContainer.prepend(div);
        applyTranslations(chatLang, div);

        if (highlight) setTimeout(() => div.classList.remove("flash"), 2500);
    }

    function renderPacketsEnsureDescending(packets, highlight=false) {
        if (!Array.isArray(packets) || packets.length===0) return;
        const sortedDesc = packets.slice().sort((a,b)=>{
            // NOTE: Temporary stopgap - fallback to import_time until old data with
            // import_time_us=0 is migrated/cleaned up. Can be simplified once all
            // legacy records have been updated.
            // Sort by import_time_us with fallback to import_time
            const aTime = (a.import_time_us && a.import_time_us > 0) ? a.import_time_us : 
                         (a.import_time ? new Date(a.import_time).getTime() * 1000 : 0);
            const bTime = (b.import_time_us && b.import_time_us > 0) ? b.import_time_us : 
                         (b.import_time ? new Date(b.import_time).getTime() * 1000 : 0);
            return bTime - aTime;
        });
        for (let i=sortedDesc.length-1; i>=0; i--) renderPacket(sortedDesc[i], highlight);
    }

    async function fetchInitial() {
        try {
            const resp = await fetch("/api/packets?portnum=1&limit=100");
            const data = await resp.json();
            if (data?.packets?.length) renderPacketsEnsureDescending(data.packets);
            lastTime = data?.latest_import_time || lastTime;
        } catch(err){ console.error("Initial fetch error:", err); }
    }

    async function fetchUpdates() {
        try {
            const url = new URL("/api/packets?portnum=1", window.location.origin);
            url.searchParams.set("limit","100");
            if (lastTime) url.searchParams.set("since", lastTime);
            const resp = await fetch(url);
            const data = await resp.json();
            if (data?.packets?.length) renderPacketsEnsureDescending(data.packets, true);
            lastTime = data?.latest_import_time || lastTime;
        } catch(err){ console.error("Fetch updates error:", err); }
    }

    async function loadChatLang() {
        try {
            const cfg = await window._siteConfigPromise;
            const langCode = cfg?.site?.language || "en";
            const res = await fetch(`/api/lang?lang=${langCode}&section=chat`);
            chatLang = await res.json();
            applyTranslations(chatLang);
        } catch(err){ console.error("Chat translation load failed:", err); }
    }

    // --- Main init ---
    await Promise.all([loadChatLang(), fetchInitial()]);
    setInterval(fetchUpdates, 5000);
});
</script>
{% endblock %}
